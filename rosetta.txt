// Fizzbuz

import io;

proc FizzFuzz() -> void
  for i in 1..100 do
    switch
      case i % 15 == 0:
        println("FizzBuzz");
      case i % 3 == 0:
        println("Fizz");
      case i % 5 == 0:
        println("Buzz");
      else:
        println("${i}");
    end
  end
end


proc FizzBuzz() -> void
{
  for (i in 1..100)
  {
    switch
    {
      case i % 15 == 0:
        println("FizzBuzz");
      case i % 3 == 0:
        println("Fizz");
      case i % 5 == 0:
        println("Buzz");
      default:
        println("{i}");
    }
  }
}

proc FizzBuzz() -> void
{
  for (i in 1..100)
  {
     if (i % 15 == 0)
     {
        println("FizzBuzz");
     }
     elif (i % 3 == 0)
     {
        println("Fizz");
     }
     elif (i % 5 == 0)
     {
        println("Buzz");
     }
     else
     {
        println("{i}");
     }
  }
}


proc mod_inverse(a : i32, m : i32) -> i32
{
  if (m == 1) -> return 0;
  m0 := m;
  x := 1;
  y := 0;
  while (a > 1)
  {
     q := a / m;
     temp := m;
     m = a % m;
     a = temp;
     temp = y;
     y = x - q * y;
     x = temp;

     /*
     Should we support this??
     (a, m) = (m, a % m);
     (x, y) = (y, x - q * y);
     */
  }
  return x < 0 ? x + m0 : x;
}

proc mod_inverse(a : i32, m : i32) -> i32
{
  if (m == 1) -> return 0;
  i32 m0 = m;
  i32 x = 1;
  i32 y = 0;
  while (a > 1)
  {
     i32 q = a / m;
     i32 temp = m;
     m = a % m;
     a = temp;
     temp = y;
     y = x - q * y;
     x = temp;
     /*
     Should we support this??
     (a, m) = (m, a % m);
     (x, y) = (y, x - q * y);
     */
  }
  return x < 0 ? x + m0 : x;
}


proc mod_inverse(a : i32, m : i32) -> i32
  if (m == 1) -> return 0;
  i32 m0 = m;
  i32 x = 1;
  i32 y = 0;
  while a > 1 do
    i32 q = a / m;
    i32 temp = m;
    m = a % m;
    a = temp;
    temp = y;
    y = x - q * y;
    x = temp;
    (a, m) = (m, a % m);
    (x, y) = (y, x - q * y);
  end
  return x < 0 ? x + m0 : x;
end

proc mod_inverse(a : i32, m : i32) -> i32
  if (m == 1) -> return 0;
  m0 := m;
  x := 1;
  y := 0;
  while a > 1 do
    q := a / m;
    temp := m;
    m = a % m;
    a = temp;
    temp = y;
    y = x - q * y;
    x = temp;
    (a, m) = (m, a % m);
    (x, y) = (y, x - q * y);
  end
  return x < 0 ? x + m0 : x;
end

// Swap:
tmp := a;
a := b;
b := tmp;

// OR a, b = b, a


// Anagram

program Anagram
{

  stream := FileStream.new()->init("unixdict.txt");
  anagramMap := Map.new()->init();
  u32 count = 0;
  while (line, eof := stream->getLine(); !eof)
  {
     chars := line->getChars();
     Array.sort(chars);
     key := String.new()->chars).autorelease();
     list := anagramMap->get(key);
     if (!list)
     {
        list := Array.new().autorelease();
        anagramMap->put(key, list);
     }
     list->addObject(line);
     count = max(count, list->count());
  }
  stream->close();
  for (key, value in list)
  {
     if (value->count() >= count)
     {
        println(String.join(value, ", "));
     }
  }
}

program Anagram

  FileStream stream = FileStream.new()->init("unixdict.txt");
  defer -> stream->close();
  Map anagramMap = Map.new()->init();
  u32 count = 0;

  while i32 line, i32 eof = stream->getLine(); !eof do
     id chars = line->getChars();
     Array.sort(chars);
     String key = String.new()->chars().autorelease();
     id list = anagramMap->get(key);
     if !list do
        list := Array.new().autorelease();
        anagramMap->put(key, list);
     end
     list->addObject(line);
     count = max(count, list->count());
  end

  for key, value in list do
     if (value->count() >= count do
        println(String.join(value, ", "));
     end
  end

end

program Anagram
begin

  FileStream stream;
  stream.init("unixdict.txt") !!
    catch
      println("Failed to open dictionary");
      exit(-1);
    end;


  defer -> stream.close();

  Map anagramMap;
  anagramMap.init();

  u32 count = 0;

  while i32 line, i32 eof = stream.getLine(); !eof
  begin
     String chars = line.getChars();
     chars.sort();
     list : List* = anagramMap->get(chars);
     if !list do
        list = alloc(Array);
        anagramMap.put(key, list);
     end
     list.addObject(line);
     count = max(count, list.count());
  end

  for key, value in list do
     if (value.count() >= count do
        println(value.join(", "));
     end
  end

end

program Anagram
{
  stream := FileStream.new()->init("unixdict.txt");
  anagramMap := Map.init();
  u32 count = 0;
  while (line, eof := stream->getLine(); !eof)
  {
     chars := line->getChars();
     Array.sort(chars);
     key := String(chars);
     list := anagramMap->get(key);
     if (!list)
     {
        list := Array.new().autorelease();
        anagramMap->put(key, list);
     }
     list->addObject(line);
     count = max(count, list->count());
  }
  stream->close();
  for (key, value in list)
  {
     if (value->count() >= count)
     {
        println(String.join(value, ", "));
     }
  }
}


program SendMail
{
   msg : MailMessage = MailMessage.stack()->init();
   msg->addRecipient(name: "Alice Moralis",
                     email: "alice@example.com",
                     MailRecipient.PRIMARY);
   msg->addRecipient(name: "Patrick Kilpatrick",
                     email: "pat@example.com",
                     MailRecipient.CC);
   msg->addRecipient(name: "Alice Moralis",
                     email: "",
                     MailRecipient.);


      msg.addRecipient (MailRecipient (MailRecipient::PRIMARY_RECIPIENT,
                                       "alice@example.com",
                                       "Alice Moralis"));
      msg.addRecipient (MailRecipient (MailRecipient::,
                                       "",
                                       ""));
      msg.addRecipient (MailRecipient (MailRecipient::BCC_RECIPIENT,
                                       "mike@example.com",
                                       "Michael Carmichael"));

      msg.setSender ("Roy Kilroy <roy@example.com>");

      msg.setSubject ("Rosetta Code");
      msg.setContent ("Sending mail from C++ using POCO C++ Libraries");

      SMTPClientSession smtp ("mail.example.com"); // SMTP server name
      smtp.login ();
      smtp.sendMessage (msg);
      smtp.close ();
      std::cerr << "Sent mail successfully!" << std::endl;
    }
  catch (std::exception &e)
    {
      std::cerr << "failed to send mail: " << e.what() << std::endl;
      return EXIT_FAILURE;
    }

  return EXIT_SUCCESS;
}
